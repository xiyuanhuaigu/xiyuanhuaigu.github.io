<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Token | 惜缘怀古的博客</title><meta name="keywords" content="惜缘怀古，博客"><meta name="author" content="惜缘怀古"><meta name="copyright" content="惜缘怀古"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TokenToken简介：Token是计算机术语：令牌，令牌是一种能够控制站点占有媒体的特殊帧，以区别数据帧及其他控制帧。token其实说的更通俗点可以叫暗号，在一些数据传输之前，要先进行暗号的核对，不同的暗号被授权不同的数据操作。基于 Token 的身份验证方法 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 1.客户端使用用户名跟密码请求登录 2.">
<meta property="og:type" content="article">
<meta property="og:title" content="Token">
<meta property="og:url" content="https://xiyuanhuaigu.gitee.io/2022/05/05/Token/index.html">
<meta property="og:site_name" content="惜缘怀古的博客">
<meta property="og:description" content="TokenToken简介：Token是计算机术语：令牌，令牌是一种能够控制站点占有媒体的特殊帧，以区别数据帧及其他控制帧。token其实说的更通俗点可以叫暗号，在一些数据传输之前，要先进行暗号的核对，不同的暗号被授权不同的数据操作。基于 Token 的身份验证方法 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 1.客户端使用用户名跟密码请求登录 2.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiyuanhuaigu.gitee.io/img/token.jpg">
<meta property="article:published_time" content="2022-05-05T09:51:22.000Z">
<meta property="article:modified_time" content="2022-05-07T11:46:31.085Z">
<meta property="article:author" content="惜缘怀古">
<meta property="article:tag" content="惜缘怀古，博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiyuanhuaigu.gitee.io/img/token.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xiyuanhuaigu.gitee.io/2022/05/05/Token/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Token',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-07 19:46:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/token.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">惜缘怀古的博客</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Token</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-05T09:51:22.000Z" title="发表于 2022-05-05 17:51:22">2022-05-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-07T11:46:31.085Z" title="更新于 2022-05-07 19:46:31">2022-05-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Token"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><h2 id="Token简介："><a href="#Token简介：" class="headerlink" title="Token简介："></a>Token简介：</h2><p>Token是计算机术语：令牌，令牌是一种能够控制站点占有媒体的特殊帧，以区别数据帧及其他控制帧。token其实说的更通俗点可以叫暗号，在一些数据传输之前，要先进行暗号的核对，不同的暗号被授权不同的数据操作。基于 Token 的身份验证方法</p>
<p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p>
<p>1.客户端使用用户名跟密码请求登录</p>
<p>2.服务端收到请求，去验证用户名与密码</p>
<p>3.验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p>
<p>4.客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p>
<p>5.客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p>
<p>6.服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p>
<h2 id="关于Token你需要知道的事："><a href="#关于Token你需要知道的事：" class="headerlink" title="关于Token你需要知道的事："></a>关于Token你需要知道的事：</h2><p>转自：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://alvinzhu.me/blog/2014/08/26/10-things-you-should-know-about-tokens/">https://link.jianshu.com/?t=http://alvinzhu.me/blog/2014/08/26/10-things-you-should-know-about-tokens/</a></p>
<ol>
<li>Token 应该被保存起来（放到 local / session stograge 或者 cookies）<br> 在单页应用程序中，有些用户刷新浏览器后会带来一些跟 token 相关的问题。而解决方法很简单：你应该把 token 保存到起来：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/auth0/angular-token-auth/blob/master/auth.client.js#L31">放到 session storage, local storage 或者是客户端的 cookie 里</a>。而浏览器不支持 session storage 时都应该转存到 cookies 里。<br> 如果你想“我把 token 保存到 cookie ，不就跟以前没有任何分别？”。可是在这种情况下你只是把 cookie 当作一个储存机制，而不是一种<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://sitr.us/2011/08/26/cookies-are-bad-for-you.html">验证机制</a>。（比如说，这个 cookie 不会被 Web 框架用于用户验证，所以没有 XSRF 攻击的危险）。</li>
<li>Tokens 除了像 cookie 一样有有效期，而且你可以有更多的操作方法<br> Tokens 应该有一个有效期（在 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-15#section-4.1.4">JSON Web Tokens</a> 中是作为 exp<br> 属性），否则其他人只要登录过一次就可以永远地通过 API 的验证。Cookies 基于同样的理由也有一个有效期。<br> 在 Cookies 的使用中，有不同的选项可以控制 cookie 的生命周期：</li>
<li> cookies 可以在浏览器关闭后删除（session cookies）；2. 另外你可以实现服务器端的检查（通常由你使用的 Web 框架完成），还有也可以实现绝对有效期或弹性有效期（sliding window expiration）；3. Cookies 可以带有有效期地保存起来（浏览器关闭后也不删除）。</li>
</ol>
<p>而在 tokens 的使用中，一旦 token 过期，只需要重新获取一个。你可以使用一个接口去刷新 token：</p>
<ol>
<li> 让旧的 token 失效；2. 检查这个用户是不是还存在，权限是否被取消或者任何对你的程序来说是有必要的；3. 得到一个更新了有效期的 token。</li>
</ol>
<p>你甚至可以把 token 原来的发布时间也保存起来，并且强制在两星期后重新登录什么的。</p>
<p>12345678910111213141516</p>
<p>app.post(‘/refresh_token’, function (req, res) { // verify the existing token var profile = jwt.verify(req.body.token, secret); // if more than 14 days old, force login if (profile.original_iat - new Date() &gt; 14) { // iat == issued at return res.send(401); // re-logging } // check if the user still exists or if authorization hasn’t been revoked if (!valid) return res.send(401); // re-logging // issue a new token var refreshed_token = jwt.sign(profile, secret, { expiresInMinutes: 60*5 }); res.json({ token: refreshed_token });});</p>
<p>如果你需要撤回 tokens（当 token 的生存期比较长的时候这很有必要）那么你需要一个 token 的生成管理器去作检查。</p>
<ol start="3">
<li>Local / session storage 不会跨域工作，请使用一个标记 cookie<br> 如果你设置一个 cookie 的域名为 .yourdomain.com<br> 它将可以被 youdomain.com<br> 和 app.yourdomain.com<br> 获取，这样用户登录并且转到app.yourdomain.com<br> 后也能很容易地从主域名找回这个 cookie（假如你的是电商网站）。<br> 而另一方面，保存在 local / session storage 的 tokens，就不能从不同的域名中读取（甚至是子域名也不行）。那你能怎么做？<br> 一个可能的选择是，当用户通过 app.yourdomain.com<br> 上面的验证时你生成一个 token 并且作为一个 cookie 保存到 .yourdomain.com</li>
</ol>
<p>1234567</p>
<p>$.post(‘/authenticate, function() { // store token on local/session storage or cookie …. // create a cookie signaling that user is logged in $.cookie(‘loggedin’, profile.name, ‘.yourdomain.com’);});</p>
<p>然后，在 youromdain.com<br>中你可以检查这个 cookie 是不是已经存在了，并且如果存在的话就转到 app.youromdain.com<br>去。从这以后，这个 token 将会对程序的子域名以及之后通常的流程都有效（直到这个 token 超过有效期）。<br>不过这将会导致 cookie 存在但 token 被删除了或其他意外情况的发生。在这种情况下，用户将不得不重新登录。但重要的是，像我们之前说的，我们不会这个用 cookie 作为验证方法，只是作为一个存储机制去支持存储信息在不同的域名中。</p>
<ol start="4">
<li>每个 CORS（跨域资源共享）请求都会带上预请求（Preflight request）<br> 有些人指出 Authorization header 不是一个<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.w3.org/TR/cors/">simple header</a>，因此对于一个特定的 URLs 的所有请求都会带上一个预请求。</li>
</ol>
<p>12345678910</p>
<p>OPTIONS <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://api.foo.com/barGET">https://api.foo.com/barGET</a> <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://api.foo.com/bar">https://api.foo.com/bar</a> Authorization: Bearer ….OPTIONS <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://api.foo.com/bar2GET">https://api.foo.com/bar2GET</a> <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://api.foo.com/bar2">https://api.foo.com/bar2</a> Authorization: Bearer ….GET <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://api.foo.com/bar">https://api.foo.com/bar</a> Authorization: Bearer ….</p>
<p>但这只会发生在你发送 Content-Type: application/json<br>时。不过这说明已经出现在绝大多数的程序中了。<br>一个小小的警告，the OPTIONS<br>请求不会带有 Authorization header 自身，所以你的网络框架应该支持区别对待 OPTISON<br>和后来的请求。（微软的 IIS 因为某些原因好像会有问题）。</p>
<ol start="5">
<li>当你需要流传送某些东西，请用 token 去获取一个已签名的请求。<br> 当使用 cookies 时，你可以很容易开始一个文件的下载或流传送内容。然而，在 tokens 的使用中，请求是通过 XHR 完成的，你不能依赖于它。而解决方法应该是像 AWS 那样通过生成一个签名了的请求，例如，Hawk Bewits 是一个很好的框架去启用它：<br> <strong>Request:</strong></li>
</ol>
<p>12</p>
<p>POST /download-file/123Authorization: Bearer…</p>
<p><strong>Response:</strong></p>
<p>1</p>
<p>ticket=lahdoiasdhoiwdowijaksjdoaisdjoasidja</p>
<p>这个 ticket 是无状态并且是基于 URL 的：host + path + query + headers + timestamp + HMAC，并且有一个有效期。所以它可以用于像只能在5分钟内去下载一个文件。<br>你然后可以转到 /download-file/123? ticket=lahdoiasdhoiwdowijaksjdoaisdjoasidja<br>中去。服务器就会检查这个 ticket 是不是有效然后像正常一样开始下一步的服务。</p>
<ol start="6">
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://baike.baidu.com/view/50325.htm">XSS</a> 比 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://baike.baidu.com/view/1609487.htm">XSRF</a> 要更容易防范<br> XSS 攻击的原理是，攻击者插入一段可执行的 JavaScripts 脚本，该脚本会读出用户浏览器的 cookies 并将它传输给攻击者，攻击者得到用户的 Cookies 后，即可冒充用户。但是要防范 XSS 也很简单，在写入 cookies 时，将 HttpOnly<br> 设置为 true<br> ，客户端 JavaScripts 就无法读取该 cookies 的值，就可以有效防范 XSS 攻击。因为 Tokens 也是储存在本地的 session storage 或者是客户端的 cookies 中，也是会受到 XSS 攻击。所以在使用 tokens 的时候，必须要考虑过期机制，不然攻击者就可以永久持有受害用户帐号。<br> 相比 XSS，XSRF 的危害性更大，因为大多数 Web 框架都已经内置了 XSS 防范机制（例如在 Ruby on Rails 中，用户的输入在输出的时候都会做转义<br> 操作，攻击者插入的脚本就无法执行），对于大部分开发者而言，甚至连 XSRF 都不知道是什么玩意，更别提防范了。XSRF 目前并不是每个 Web 框架都有防范机制，因此开发者更应该留意 XSRF 。</li>
<li>注意 token 的大小<br> Token 机制在每次请求 API 的时候，都需要带上一个 Authorization<br> 的 Http Header 。</li>
</ol>
<p>123</p>
<h1 id="TokenGET-fooAuthorization-Bearer-…2kb-token…"><a href="#TokenGET-fooAuthorization-Bearer-…2kb-token…" class="headerlink" title="TokenGET /fooAuthorization: Bearer …2kb token…"></a>TokenGET /fooAuthorization: Bearer …2kb token…</h1><p>123</p>
<h1 id="CookieGET-fooconnect-sid-…20-bytes-cookie…"><a href="#CookieGET-fooconnect-sid-…20-bytes-cookie…" class="headerlink" title="CookieGET /fooconnect.sid: …20 bytes cookie…"></a>CookieGET /fooconnect.sid: …20 bytes cookie…</h1><p>Token 的大小其实由你储存在 token 中的信息量所决定，例如可能有 nickname<br>，openid<br>等开发者另外加上的信息。<br>但是 session cookies 机制只需要一个字串作为用户标识即可（例如 PHP 的 PHPSESSIONID），其中关于用户的信息都会直接储存到服务端的数据库中，当用户请求时才从数据库中捞出来用。<br>当然 Token 机制也可以仿照 session cookies 机制这么做了，也是个有效控制 token 大小的方法。<br>Token 中只保留关键的几条身份标识信息，其余都放到数据库里面了，权限控制的时候再捞出。这样做的好处是，开发者可以完全掌控 token，因为关键信息都已经是你代码和数据库中的一部分了，想怎么弄都可以了。<br>举个例子：</p>
<p>123</p>
<p>GET /fooAuthorization: Bearer ……500 bytes token….Then on the server:</p>
<p>12345678910</p>
<p>app.use(‘/api’, // 首先检查 token； expressJwt({secret: secret}), // 然后再从数据库中捞出用户信息。 function(req, res, next) { req.user.extra_data = get_from_db(); next(); });</p>
<p>另外值得一提的是，你也可以把东西都丢 Cookies 里面（而不是只丢个身份标识字串）。只要确保资料经过了严格的加密，攻击者无法利用，现在有些 Web 框架已经有类似机制，例如 Nodejs 的这个插件 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/mozilla/node-client-sessions">mozilla/node-client-sessions</a>。</p>
<ol start="8">
<li>有需要的话，要加密并且签名 token<br> 虽然 TLS/SSL 机制可以隔绝大多数中间人攻击，但是如果 token 中带有了用户的敏感信息，开发者也应该要加密这些信息。<br> 使用 JWT（文中第 9 点） 可以加密 token，但是由于目前大多数 Web 框架还未支持 JWT，所以可以使用 AES-CBC 算法加密 token。</li>
</ol>
<p>1234567891011121314151617181920</p>
<p>app.post(‘/authenticate’, function (req, res) { // 校验用户； // 加密 token； var encrypted = { token: encryptAesSha256(‘shhhh’, JSON.stringify(profile)) }; // 给加密后的 token 签名； var token = jwt.sign(encrypted, secret, { expiresInMinutes: 60*5 }); res.json({ token: token });}function encryptAesSha256 (password, textToEncrypt) { var cipher = crypto.createCipher(‘aes-256-cbc’, password); var crypted = cipher.update(textToEncrypt, ‘utf8’, ‘hex’); crypted += cipher.final(‘hex’); return crypted;}// 上面就是 encrypt-then-MAC （加密后签名）做法。</p>
<p>当然你也可以用文中的第 7 点，直接将敏感信息丢数据库中。</p>
<ol start="9">
<li>将 JSON Web Tokens 应用到 OAuth 2<br> OAuth 2 是一个解决身份验证的授权协议，并且广泛地使用了 token 。<br> 用户通过 OAuth 2 协议授权第三方应用权限，然后服务器返回一个 access_token<br> 给第三方应用，通常也带有 scope<br> 参数，第三方应用通过带上access_token<br> 请求服务器，可以在授权范围（scope）内调用 API。<br> 一般来说，类似这种 token 是不透明的，就是核心数据都储存以 hash-table 结果储存在服务器中，客户端只持有一个令牌<br> （access_token），任何人都可以用这个令牌在授权范围（scope）内调用服务器端的 API。<br> Signed tokens（例如 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://jwt.io/">JWT</a>)）和这种形式的 token 最主要的区别是，JWT 是无状态的，它不储存在服务端 hash-table 中，服务端中不保留 JWT 请求的相关信息，JWT 会把授权信息和 API 调用返回都丢一起返回给客户端。<br> JWT 通常以 Base64 + AES 方式编码传输。OAuth 2 协议也支持 JWT，因为 OAuth 2 并未限制 access_token 数据格式，你可以将 JWT 应用在 OAuth 2 上。</li>
<li>Tokens 不是万能的解决方法，得根据你的需求自行采用<br>这些年来，我们帮助过不少大公司实现了他们的以 Token 为基础的验证授权架构。曾经有一家 10k + 员工，有着大量数据的公司，他们想实现一个中央权限管理系统，其中有一个需要是某个员工只能读取某个国家某个医院某个床位的id<br>和name<br>字段数据，想想这样的细粒度的权限管理是多么难实现，无论是技术上还是行政上。<br>当然采用 tokens 与否，得看大家的具体需求，但是，要忠告大家的是，不要什么内容都写到 tokens 了，加之前想想有没有这个必要。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">惜缘怀古</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xiyuanhuaigu.gitee.io/2022/05/05/Token/">https://xiyuanhuaigu.gitee.io/2022/05/05/Token/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xiyuanhuaigu.gitee.io" target="_blank">惜缘怀古的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/token.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/08/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><img class="prev-cover" src="/img/PHPfanxu.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PHP反序列化</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/03/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%B8%B8%E7%94%A8%E8%B7%AF%E5%BE%84/"><img class="next-cover" src="/img/wenjiianxiazai.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">文件下载常用路径</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">惜缘怀古</div><div class="author-info__description">唯有那份炫目，未曾忘却</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Token"><span class="toc-number">1.</span> <span class="toc-text">Token</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Token%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">Token简介：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EToken%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">关于Token你需要知道的事：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TokenGET-fooAuthorization-Bearer-%E2%80%A62kb-token%E2%80%A6"><span class="toc-number">2.</span> <span class="toc-text">TokenGET &#x2F;fooAuthorization: Bearer …2kb token…</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CookieGET-fooconnect-sid-%E2%80%A620-bytes-cookie%E2%80%A6"><span class="toc-number">3.</span> <span class="toc-text">CookieGET &#x2F;fooconnect.sid: …20 bytes cookie…</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/13/kali-WIFI%E6%94%BB%E5%87%BB/" title="kali WIFI攻击"><img src="https://xyhutc.oss-cn-qingdao.aliyuncs.com/giteetuchuang/f08e07cfb3768ac97a690c2dd413eac72a68ae86_raw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kali WIFI攻击"/></a><div class="content"><a class="title" href="/2022/09/13/kali-WIFI%E6%94%BB%E5%87%BB/" title="kali WIFI攻击">kali WIFI攻击</a><time datetime="2022-09-13T12:26:16.000Z" title="发表于 2022-09-13 20:26:16">2022-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/11/AWD%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8WEB%E7%AF%87/" title="AWD新手入门WEB篇"><img src="https://xyhutc.oss-cn-qingdao.aliyuncs.com/giteetuchuang/e9eb0702db182d690f80a88899cc212e7bf2ba24_raw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AWD新手入门WEB篇"/></a><div class="content"><a class="title" href="/2022/09/11/AWD%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8WEB%E7%AF%87/" title="AWD新手入门WEB篇">AWD新手入门WEB篇</a><time datetime="2022-09-11T08:40:44.000Z" title="发表于 2022-09-11 16:40:44">2022-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/08/iWrite-%E4%B8%8D%E8%AE%A9%E7%B2%98%E8%B4%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" title="iWrite 不让粘贴的解决办法"><img src="https://xyhutc.oss-cn-qingdao.aliyuncs.com/giteetuchuang/c26ad5f7afd9ae7f1975da8b781398f0d5214b0a_raw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="iWrite 不让粘贴的解决办法"/></a><div class="content"><a class="title" href="/2022/09/08/iWrite-%E4%B8%8D%E8%AE%A9%E7%B2%98%E8%B4%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" title="iWrite 不让粘贴的解决办法">iWrite 不让粘贴的解决办法</a><time datetime="2022-09-08T09:31:35.000Z" title="发表于 2022-09-08 17:31:35">2022-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/06/Tmux/" title="Tmux"><img src="https://xyhutc.oss-cn-qingdao.aliyuncs.com/giteetuchuang/1660359611276.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tmux"/></a><div class="content"><a class="title" href="/2022/09/06/Tmux/" title="Tmux">Tmux</a><time datetime="2022-09-06T09:59:41.000Z" title="发表于 2022-09-06 17:59:41">2022-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/12/MySQL-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/" title="MySQL 常用语法"><img src="https://xyhutc.oss-cn-qingdao.aliyuncs.com/giteetuchuang/54b06695bd0ac7623a44db30ae7acb516eaf374e_raw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL 常用语法"/></a><div class="content"><a class="title" href="/2022/08/12/MySQL-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/" title="MySQL 常用语法">MySQL 常用语法</a><time datetime="2022-08-12T06:41:03.000Z" title="发表于 2022-08-12 14:41:03">2022-08-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 惜缘怀古</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>